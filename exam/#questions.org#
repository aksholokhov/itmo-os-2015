# (C) 2014-2015 Jan Malakhovski
# Version 3.1
* Базовые представления о том, чего там внутри делают компьютеры
** Исполнение кода CPU и прерывания.
** Привилегированный и непривилегированный код и его аппаратная поддержка.
** Виртуальное и физическое адресные пространства.
** Устройства ввода.
* Базовые представления об операционных системах
** Классический тред — указатель текущей инструкции, стек, local storage.
** Классический процесс — набор тредов, куча и ресурсы.
** Системные вызовы и механизмы их реализации.
** Сигналы и их аппаратная природа.
** Планировка процессов.
** Файловые системы.
** Пользователи и права.
** Хендлы, файловые дескрипторы как способ адресации к ресурсам.
* Базовые представления из теории языков программирования
** Стрелочные типы.
** Типы-варианты, Σ-типы.
** CPS-преобразование.
* PLTшная модель операционной системы
** Process r = r -> Context; Context = Σ SysCallTag (λ s → Arg s × Process (Res s)).
** Прерывания. Системные вызовы.
*** readLine, writeLine,
*** yield, exit,
*** fork, exec, spawn, wait,
*** open, read, write, close.
** Вымещение (по таймеру, по событиям) как yield.
* Стандартные утилиты и встроенные команды shell
** cd, pwd
** ls, ps
** cat, grep
** Перенаправления ввода-вывода в sh
*** в файлы, из файлов
*** << EOF
*** <<< expr
*** exec > ./file, exec < ./file, ...
** chmod, chown
** find
** sort, uniq
** xargs
** sed, awk
** diff, patch
* Знания о низкоуровневых вещах без которых нельзя
** Общая архитектура современных компьютеров.
*** IBM PC: CPU, северный и южный мосты, память, устройства, кеши процессора.
*** Встроенные системы.
** RAM.
*** SRAM, DRAM.
*** Структурно-операционная схема обычной планки памяти (DDR*).
** Интерфейс между памятью и CPU.
** Кеши CPU.
*** Общая организация кешей: L1, L2, L3, ...
*** Схема параллельного извлечения.
*** Извлечение демультиплексором.
*** Ассоциативность.
*** TLB.
*** Общее влияние кеша на работу с памятью.
*** Кеши в мультипроцессорных системах и когерентность кешей.
** Глубокий внутренний мир CPU.
*** Пайплайн (pipeline): fetch, decode, ..., execute, commit.
*** Регистровый файл.
*** Пузыри (pipeline bubbles).
*** Предсказание переходов (branch prediction).
*** Out of order исполнение.
** Интерфейс между устройствами ввода и CPU.
*** Прерывания.
*** DMA.
** Виртуальная память.
*** MMU: TLB, каталог страниц (page table).
*** Биты, регулирующие поведение при обращении к страницам:
**** readable, writeable, executable, present,
**** dirty, copy-on-write.
**** Их назначение и эмуляция через друг друга.
*** IOMMU.
** Дисковые устройства и их особенности:
*** HDD,
*** SSD.
** Интерфейсы работы с
*** устройствами ввода,
*** видеопамятью,
*** жесткими дисками,
*** сетевыми картами,
*** звуковыми картами.
* Знания об операционных системах без которых нельзя
** Память процессов.
*** "География" адресного пространства процесса.
**** Program break.
**** VMA на дереве отрезков.
*** Структуры ядра описывающие процесс с MMU:
**** работа с физической памятью,
**** VMA.
*** Системные вызовы для аллокации памяти:
**** brk, sbrk,
**** mmap.
*** Общая память:
**** mmaping файлов,
**** shm_open.
*** Пулы памяти со специальными требованиями.
*** Реализация malloc.
** Процессы и треды.
*** fork (POSIX и близкие ОС).
**** init, родители, дети, зомби.
**** Треды, группы тредов, процессы.
**** Системные вызовы fork, clone, exec, wait.
**** Интерфейс bash.
*** TODO spawn (другие ОС).
*** Структуры данных ядра.
*** Реализация переключения контекстов процессов.
** Поддержка библиотечного кода.
*** fork-exec-deduplication.
*** Динамическая линковка и загрузка.
** Файловые дескрипторы и пайпы.
*** Системные вызовы open, read, write, close.
*** Перенаправление ввода-вывода:
**** на bash,
**** на C.
*** Структуры данных ядра:
**** таблица файловых дескрипторов,
**** файловые объекты POSIX, флаг CLOEXEC.
*** Системный вызов dup2.
*** Пайпы в пространстве пользователя:
**** на bash,
**** системный вызов pipe,
**** на C.
*** Пайпы в пространстве ядра:
**** структуры данных,
**** реализация read и write.
** Драйвера устройств в пространстве ядра.
*** Прерывания.
<<driver-ints>>
**** Монолитная обработка прерываний.
**** Hi/Lo прерывания.
*** Polling.
*** Упрощённый пример: tty как двунаправленный пайп до монитора и клавиатуры.
** Файловые системы.
*** Плоская, деревянная, реляционная.
*** Структура данных inode.
*** Представление на диске:
**** обычный файл,
**** символьная ссылка,
**** директория,
**** жесткая ссылка,
**** файл-устройство (символьное, блочное).
*** VFS.
**** Структуры данных пространства ядра: FSObject, Namespace.
**** Path resolution: системный вызов open.
**** Операции над неймспейсами:
***** mount,
***** bind mount, move mount,
***** chroot,
***** pivot_root.
**** Linux FUSE.
*** ФС как функция inodeno → inode со встроенным path resolution.
*** mmaping файлов.
*** Структуры пространства ядра.
**** Файловый дескриптор на:
***** устройство,
***** файл,
***** директорию.
**** Файловый кеш и mmapинг.
**** Кеш директорий.
** Пользователи и права.
*** Модели прав доступа к объектам: дискретная и ролевая.
*** Права на объекты файловой системы.
*** Пользователи и группы с точки зрения ядра.
*** Пользователи и группы с точки зрения пространства пользователя.
**** Системные вызовы setuid, setgid и товарищи.
**** setuid bit.
**** PAM.
**** /etc/passwd,
**** /etc/shadow,
**** /etc/group.
*** Capabilities.
*** rlimits.
** Сигналы.
*** Стандартные сигналы.
**** Для чего они нужны.
**** Системный вызов kill.
**** Ignored, blocked, pending маски.
**** Правила доставки.
*** Реалтаймовые сигналы.
**** Для чего они нужны.
**** Маски и очереди.
**** Правила доставки.
*** Прерывание сигналами:
**** кода программы,
**** обработчиков сигналов,
**** системных вызовов.
*** Реентрабельность и безопастные системные вызовы.
*** Сигналы и треды.
*** Другие возможности настройки, системный вызов sigaction.
*** Семантика сигналов:
**** TERM, KILL,
**** STOP, CONT,
**** CHLD,
**** PIPE,
**** ILL/FPE, SEGV, BUS.
** Мултиплексирование ввода-вывода.
*** O_NONBLOCK.
*** Edge и level triggered события.
*** Преобразование асинхронного ввода-вывода в kinda синхронный CPS-преобразованием.
*** Структуры данных пространства ядра для реализации мультиплексора файловых дескрипторов.
*** Системные вызовы select, poll, epoll.
*** Управление скоростью передачи данных через файловые дескрипторы.
*** ДЗ: Реализация пайпов в пространстве пользователя.
** Синхронизация.
*** Спинлоки.
*** Ядерные семафоры (cf. sem_overview(7)).
*** Блокировки на файлы.
**** Структуры данных пространства ядра.
**** Системные вызовы flock, fcntl.
** Сетевой стек.
*** PPP, Ethernet. IP. TCP, UDP, SCTP.
*** BSD sockets (cf. BeeJee's Network Guide).
**** Философия API.
**** Stream-сокеты.
**** Datagram-сокеты.
**** RAW-сокеты.
**** Файловый объект для accept-сокета.
* Мета-теория
** Пропускная способность против отзывчивости.
** Микро-, макро- и экзо-ядерные операционные системы: особенности реализации
*** работы с памятью,
*** дисковыми ресурсами,
*** другими ресурсами,
*** системных вызовов (и подобных механизмов),
*** IPC.
*** NOTE что тут тонкие материи. Маркеры понимания тут — когда понятно:
**** что экзоядерные библиотеки — это что-то очень странное с точки зрения традиционных ОС;
**** как реализовать макроядерный хендлинг ресурсов на экзоядерных "шейдерах".
* Глубокий внутренний мир и тайные знания
** Терминалы и управление заданиями в POSIX.
*** Терминалы, псевдотерминалы и режимы их работы.
*** readline и стандартные сочетания кнопок.
*** Группы процессов и сессии.
*** Foreground и background группы.
*** Сигналы:
**** INT, HUP,
**** TSTP, TTIN, TTOU,
**** WINCH.
*** Демоны и демонизация.
** Запуск системы
*** Загрузка компьютера.
**** Первоначальная загрузка компьютера: BIOS → MBR.
**** Деление дисков на разделы: DOS Label.
**** Загрузчик операционной системы:
***** DOS/Windows boot,
***** GRUB.
*** Загрузка UNIX-like систем.
**** Ядро, корневая файловая система и initrd.
**** Инициализация системы
***** примитивная,
***** учитывая зависимости,
***** resource/socket activation,
***** lazy activation.
**** Стандартные init системы:
***** System V init (не забыв про runlevel),
***** Upstart,
***** OpenRC,
***** systemd.
**** Стандартные демоны:
***** init,
***** syslog,
***** klog,
***** cron,
***** at,
***** sshd.
**** Стандартные файлы /etc:
***** fstab, mtab,
***** sysctl.conf,
***** motd,
***** issue,
***** nologin.
** Запуск программ, динамическая линковка и загрузка.
*** Запуск программ: exec magic и интерпретаторы.
*** Релокация кода: релокационные дырки, кеширование релокаций, GOT, PIC.
*** Объектные, исполняемые и библиотечные файлы. Формат ELF.
*** ld-linux и его x86_32шные ужасы.
*** Гипотетические возможности.
**** Динамический контроль за соблюдением ABI.
**** Алгоритм динамической загрузки Малаховски-Сорокина.
** Аллокация ресурсов
*** Аллокация памяти.
**** Алгоритмы и их свойства:
***** linear list,
***** log,
***** SLAB,
***** Buddy,
***** Hoard.
**** Выделение выравненной памяти.
**** Трюки при реализации:
***** mmap выравненной памяти,
***** коварный способ использования выравниваний
для композирования различных типов аллокаторов
(я такого больше нигде не видел, но идея не сложная,
потому сомневаюсь является ли это алгоритмом Малаховски
или это уже где-то используется),
***** per-thread storage.
*** Распределённая аллокация памяти.
**** NUMA системы.
**** Memcached.
*** Аллокация дискового пространства и файловые системы.
**** Device mapper.
***** Сходства и отличия по отношению к динамическим аллокаторам памяти.
***** Логическое управление томами.
***** RAID.
***** Шифрование данных.
***** Примеры (с указанием формата данных на диске):
****** mdadm,
****** LVM,
****** cryptsetup/luks.
**** Файловые системы ((!) в примерах — требуется указания формата данных на диске).
***** Сходства и отличия по отношению к динамическим аллокаторам памяти.
****** Примеры: tmpfs.
***** Статические файловые системы.
****** Используемые структуры данных.
****** Формат на диске.
****** Примеры:
******* cpio (!),
******* iso9660 (!),
******* squashfs.
***** Динамическая аллокация блоками и экстентами.
****** Используемые структуры данных.
****** Формат на диске.
****** Примеры:
******* FAT (!), ext2 (!),
******* XFS (!).
***** Журналирование.
****** Классические журналирование:
******* физическое,
******* логическое,
******* конструкция Малаховски.
****** LogFS.
****** Гибриды LogFS и классических файловых систем.
****** Журналирование с жертвами.
****** Примеры:
******* ext3/4 (journal, ordered, writeback),
******* raiser 3/4.
***** Продвинутые возможности:
****** on the fly fsck,
****** on the fly grow,
****** on the fly shrink,
****** checksumming,
****** object-level RAID,
****** object-level шифрование,
****** snapshots,
****** multiroot,
****** транзакции (и почему их так тяжело вписать в POSIX).
***** Ещё примеры:
****** ZFS, btrfs.
*** Сетевые диски.
**** Особенности.
**** Примеры (с описанием протокола работы):
***** ndb,
***** drbd.
*** Сетевые файловые системы
**** Особенности.
**** Примеры (подробно, но без описания протокола работы):
***** NFS,
***** sshfs,
***** 9P.
*** Системы контроля версий.
**** Типы:
***** встроенные в файловую систему,
***** централизованные,
***** распределённые.
**** Структуры данных.
**** Примеры ((!) — требуется указания формата данных на диске):
***** ext3-cow,
***** cvs, svn,
***** git (!), mercurial (!).
*** Распределённые файловые системы.
**** Примеры:
***** Google GFS,
***** git.
*** Дисковые устройства и файловые системы на кластерах.
**** Особенности (не забыв про fencing).
**** Примеры:
***** Clustered LVM,
***** Redhat GFS 1/2.
** Планирование использования ресурсов
*** Формальные определения:
**** ресурсы, потребители ресурсов,
**** приоритеты, batch-приоритет.
**** желаемый приоритет потребителя ресурсов,
**** реальный приоритет потребителя ресурсов,
**** инверсия приоритетов.
*** Стратегии учёта приоритетов:
**** FIFO (First In First Out),
**** RR (Round-Robin),
**** пропорционально приоритету.
*** Планирование исполнения процессов.
**** FIFO, RR.
**** Статическое пропорциональное планирование для встоенных систем.
**** Алгоритмы пропорционального планирования:
***** точный за O(log n),
***** приближённый за амотризированное O(1),
***** алгоритм ядра Linux,
***** TODO алгоритм Малаховски.
**** Планирование с deadline'ами.
**** Нечестность приоритетов при приближённом планировании.
**** Инверсия приоритетов на блокировках и борьба с ней.
**** Планирование в реалтаймовых системах.
***** Вымещение кода ядра.
***** Вымещение прерываний.
REFS: [[driver-ints]]
***** Вымещения планировщика.
**** Планировка процессов в POSIX.
***** Обычные и реалтаймовые приоритеты и их планирование.
***** Системные вызовы shed_getscheduler, shed_setscheduler.
*** Планирование дискового ввода-вывода.
**** Отличия между планированием процессов и планированием ввода-вывода:
***** стоимость планирования,
***** доступная планировшику информация.
**** Планирование для SSD:
***** FIFO,
***** write-anticipatory.
**** Планирование для HDD:
***** двунаправленный лифтовый планировщик,
***** однонаправленный лифтовый планировщик.
**** Deadline.
**** Anticipatory.
**** Инверсии приоритетов.
**** CFQ.
*** Микширование звука.
**** Эффективное микширование.
**** Интерактивное микширование.
*** Планирование передачи пакетов.
**** Особенности планирования передачи пакетов:
***** классификация пакетов,
***** классификация соединений,
***** QOS.
**** Планирования для сети:
***** дырявое ведро (leaky bucket),
***** токенизированное ведро (token bucket).
**** Алгоритм поиска оптимальной скорости передачи.
**** RR, WRR.
**** HTB.
**** SFQ, QFQ.
**** HFSC.
**** Самое узкое место и инверсия приоритетов.
**** Полезная инверсия приоритетов.
*** Полезные выводы.
**** Общий метод борьбы с инверсией приоритетов — пропагация уважения.
**** Хороший планировщик для ресурса — это композиция
     заточенного на физику планируемого ресурса безпририоритетного планировщика
     с какой-то кашей из других планировщиков, планирующих очередь запросов
     с учётом приоритетов и прочих требований.
     Таким образом и инверсий приоритетов нет (там где не надо), и ресурс
     используется эффективно.
** Make me unsee.
*** System V shared memory, semaphores, message queues.
*** POSIX aio.
*** Лизинги на файлы.
*** ptrace.
*** X11.
*** D-bus.
* TODO Планирование эффективного использования памяти.
